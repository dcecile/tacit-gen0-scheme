Top choices:
- Gambit: Coverage (none)
- Haskell: Fail fast (lazy)
- ECL: Coverage (none)
- CCL: Coverage (unreliable with macros)

Requirements:
- Cross-platform: Linux, Windows
- Purity: lambdas are okay
- Unicode: UTF8 I/O, and full codepoint general category
- Generics: 100/1 not 10/10
- Fail-fast: no laziness or null pointers
- Namespaces: simple, and conflict resolution
- FFI: simple custom bindings
- Interactivity: full-featured REPL
- Profiling: hotspots
- Responsive: startup time and quick IO
- Coverage: sub-expression

Rejected:
- ABCL: Responsive (startup over 200ms)
- Bigloo: Unicode (not at REPL)
- Chicken: Unicode (not at REPL)
- CLisp: Cross-platform (Cygwin only)
- Clojure: Responsive (startup over 1s)
- Erlang: Responsive (startup over 150ms)
- Factor: Cross-platform (too tough to build on Linux)
- Falcon: Interactivity (alpha REPL)
- Gauche: FFI (none)
- Guile: Unicode (not at REPL)
- Ikarus: Cross-platform (only Cygwin Windows)
- Io: Cross-platform (tough to run even on Linux)
- Kawa: Responsive (startup over 200ms)
- Larceny: Responsive (startup over 1s with required SLIB)
- Lua: Unicode (just ASCII)
- Mosh: Interactivity (impossible to preload or reload libraries)
- Ocaml: Unicode (not at REPL)
- Perl: Interactivity (reloading modules with syntax errors borks the system)
- Python: Purity (unweildy lambdas)
- PLT: Interactivity (full system reload is required to see changes)
- Pure: Responsive (over 4s to load REPL when using ICU FFI)
- Rakudo: Unicode (not at REPL)
- Rhino: Responsive (startup over 200ms)
- Ruby: Interactivity (unstable debugger, no easy break on exception)
- SBCL: Cross-platform (tough Windows setup including ASDF)
- Scala: Responsive (startup over 200ms)
- Tracemonkey: Unicode (no general category)
- V8: Unicode (no general category)
- Ypsilon: Interactivity (no live data during exceptions)
