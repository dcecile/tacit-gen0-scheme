\chapter{Aspirations}

This chapter begins the description of Cottontail from an
implementor's point of view. It is a series of requirements, budgets,
and design decisions. Although general users of the language may
benefit from this detailed description, its reading should not be
required for writing Cottontail programs.


\section{Demonstration}

\begin{ccode}
% At its core, Cottontail tries to be a plain language

% Expressions written in postfix form
distance =
  speed time *
    % Whitespace is encouraged
    0.5 acceleration time 2 ** *
    +

% Functions can be specified with or without parameters
square x == x 2 **
cube == 3 **

% Colons can be substituted for brackets
[1 2 8] ls
  [x -> x say] each
[1.6e1 0x0020 0064] ls
  each: x ->
    x say

% Underscores can be placeholders for colons
_ ls [say] each:
  7 8
  9

% Loops are done with lambdas
1 10 from-to
  map: 3 *
  filter: x ->
    x 2 mod 0 eq
  each: say

% Or recursion can be used for looping
count-down x ==
  when:
    x 0 eq,
      "done" say
    else,
      x say
      x 1 - count-down

%[% Block comments
  %[% are %]% %]% "recursive" say

% Records look like variable assignment
person = mk:
  name = "Fred"
  age = current-year 1_953 -

% Member assignment has no side effects
fred = person
person.name = "Joe"
fred.name say

% Unless pointers are used
person = person xtn:
  job = "Clerk" !ref
joe = person
person.job!* = "Boss"
joe.job* say

% Overloading is implied
say person ==
  % String interpolation works with any expression
  "Hi, I'm [[person.name "!" cat]]" say

% And that's it, except for some metaprogramming glue sprinkled in
\end{ccode}


\section{Character}

Cottontail exists because C++ can't be used to script video games. A
flexible notation keeps the language nimble enough to be used for
scripting, while generic types make it fast enough for good
framerates. The result is a confused language, trying to be two things
at once. But through its confusion, it will not give up its
responsibility to fulfil both roles. A lot of the meaning of a
Cottontail program is in between the lines. The language works hard so
that the programmer can focus on creativity.

As every language must, Cottontail focuses on a few key ideas. Its
syntax mimics the mundane parts of Python, while it uses reverse
Polish notation to decimate precedence rules and expression nesting.
From Haskell, it adopts a grudge against side effects; although it
favours immediate evaluation and avoids shared data. Its preprocessor
and metaprogramming system is just a brute force compile-time
evaluator. And its generics and function overloading are loosely
inspired by the success of C++. These facets taken together form the
basis for Cottontail's stubborn character, because they're its
strategy for being a high-performance scripting language.


\section{Performance}

Beating C++ in game performance is the goal. It should be possible
with purity guarantees, ad-hoc calling conventions, run-time CPU
specializations for SIMD, and a simple threading model. Generic
specialization and code locality may give minor boosts against C++. It
could be that having a smaller language, and an extremely smaller
compiler code-base than GCC and LLVM will make optimizations much
easier to realize. All this means that Cottontail will generate its
own machine code.


\section{Interactivity}

The flip side of a general purpose game programming language is being
useful for game design. When your game designer hat is on, you don't
want to wait for something to recompile and restart, you want to see
how your changes affect gameplay. This could be during level design,
or during mechanics or UI design. When you're ready to try out your
changes, Cottontail will recompile your game (including your scripts),
load the new code into memory, and continue running. This is similar
to Erlang's hot-swapping, but is complicated by Cottontail's machine
code and static types. It doesn't seem like Cottontail has any
advantages over C++ or Java for hot-swapping, so hopefully it suceeds
in Cottontail just because it's part of the specification. Besides any
code reloading built into a game, Cottontail will always support the
read-eval-print loop (REPL) for interactive development.

Running ad-hoc code will be a technical achievement, but the language
itself also has been made suitable for scripting. This means no type
declarations and no curly braces. Anything that makes the language
unapproachable for beginners will hinder an expert trying to make
iterative changes. Reading and writing Cottontail code should
ultimately be a straightforward task, with no convoluted rules
involved. Only then is the code itself suitable for interactive
development.


\section{Game development}

As a language intended to be used for writing games, Cottontail must
include support for player input, text, graphics, music, and sound.
Some support for file formats would be helpful too. Because games are
run by user input, the event-driven style should be fully encouraged.
Finally, for performance multiple threads should be available to use.


\section{Microscalability}

``Microscalability'' is a made-up word for adding to existing code, at
the token level. If you want another conditional clause, or a new
record property, you shouldn't have to jump through hoops. This
applies to enumerated values, function overloads, and compile-time
values, as well. In expressions, functions can be inserted without any
parentheses, and newlines can be added as needed---this is especially
important for map/filter/reduce chains. Creating a new module does not
cost an arm and a leg (there are no arcane incantations and no extra
levels of indentation). Recursive block comments is a feature put in
with this in mind: surrounding a section of code in block comments
doesn't require modifying the block comments already in that section,
only two edits are required. And that's the objective; simple changes
should only require simple, local code edits.


\section{Growth}

Cottontail is not a language that will be complete from the beginning.
New users will bring new needs, and even the needs of old users will
change with time. Not only that, but certain areas will remain
incomplete for lack of resources, to be finished at a later date. This
reality must be acknowledged in the design of Cottontail.

A language certainly includes its surrounding ecosystem, so part of
the solution is a loosely interdependent set of libraries, contributed
by users (just like CPAN). The other part is flexible design of the
language itself. There needs to be a process and a means for
extending, and sometimes changing the language. PEPs and the Python
language serve as a decent model here. For any language flaws known in
advance (even flaws of omission), a maintenance path should be
devised.

Lisp's approach here is also worth noting. In Lisp, almost any new
language feature can be written as a user library. This way, users are
given the same responsibility and power as the language designer. In
Cottontail, the boundary between library and core language should be
shifted as far as possible towards expanding the power of libraries.
This should help greatly in growing the language, because some core
language changes may simply involve incorporating advanced user
libraries into the base set of standard libraries. Lisp uses macros to
accomplish this; Cottontail will use a combination of generics and
metaprogramming expressions.


\section{Vocabulary}

For text that is intended to be continually rewritten and reread, the
choice of words is vital. It's fine to use baby words to help
beginners (infants, really) learn the language, and it's important for
experts that the common words are terse and logical. The vocabulary of
Cottontail's standard functions needs to be designed as a whole, with
an ear for simplicity and symmetry. Easy words should be easy to
remember. Common words should be short, like they are in a natural
language. Related words should have a logical relationship, whether
they are antonyms or they implement similiar tasks.


\section{Genericism}

To program in Cottontail using a small, consistent rule set, some
operations should be applicable to different kinds of values.
What is sometimes called ``polymorphism'', Cottontail will call
``genericism''. Instead of focusing on inheritance, methods, and
objects, Cottontail puts the emphasis on functions and data.

On one level, Cottontail supports data inheritance. One record
can serve as a prototype for a new record, with the new record
extending the properties of the old one. Any operations applicable
to the base prototype are applicable to the new record.

Functions themselves are always generic, in the sense that they always
allow any data that meets their requirements. A function to reverse a
list will always operate on a list containing elements of any kind,
without writing any special code. Likewise, a function that prints a
person's name will work with any record, as long as the name property
is present. It is impossible to restrict the applicability of a
function using parameter type annotations, because types can't be
written down in Cottontail.

Going further, any function can be overloaded, so that a special
implementation is picked, depending on the data being operated on.
Thus, lists can be appended together using the same function as
strings, even though they are fundamentally different kinds of
data---the append operator has been overloaded for the different use
cases. Technically, the overloading supports single-dispatch and
multi-dispatch, and while compile-time dispatch is preferred, runtime
dispatch is chosen automatically if needed. Dispatch is based on the
data requirements of each overload, which are usually different
combinations of required property types (alternatives are available
through metaprogramming).

Unlike in C++, Cottontail genericism is intended to be widely used in
a programmer's general code, and not just for abstract data types such
as lists, vectors, and queues. It should prove to be a powerful
abstraction technique, activated silently when any code requires it.


\section{Referential transparency}

Any programmer who's used a functional language like Haskell or Scheme
will recognize an obsessive distrust of shared, mutable state. Even a
C programmer will be able to recount the horrors of global variables.
This is data that can be changed at any time, and you can't count on
it between two lines of code; any work done with these variables will
be through unexpected side effects.

Functional programming champions the practice of writing small
functions that work like mathematical expressions: any relevant
variables are passed in, and no values ever get changed behind the
scene. The theory is that the boost in reasoning power that you get
from a small, stable set of variables leads to code that is more
correct. This style is helpful during both unit testing and REPL
session, because a ``pure'' function called with the same parameters
should always return the same results (this is called referential
transparency).

You may have guessed by now that Cottontail follows this doctrine.
Opposed to a language like Java, which seems designed for making webs
of cross-manipulating objects, Cottontail encourages a style simple
expressions and local transformations. Even an operation as simple as
reassignment, in Cottontail, it isn't a mutation of a variable, it's
binding a new variable that happens to use the same name. Changing a
variable's property also rebinds that variable.

At a larger scale, Cottontail takes the route of ``no sharing'',
rather than the traditional ``no mutation'' route. The code may look
similar, but regular ``persistent data structures'' won't work, and
the performance during execution should be closer to C++. No sharing
means that records won't hold pointers to each other, but they'll hold
separate copies. Modifying a local copy won't affect anyone else, so
it is allowed (and runs like C++). Also, full copies lend themselves
to call-stack allocation, so garbage collection should be kept to a
minimum.


\section{Investigation}

A language designed for performance can only go so far with automatic
optimizations. Once premature optimization is no longer a worry, the
programmer will want to squeeze the last bits of performance out of
their code. This requires an extremely accurate view of where time is
spent.

For this requirement, and others like it where the user wants to
investigate the code they've writtne, Cottontail will provide a web
interface built for browsing annotated code, not unlike the Valgrind
UI. Depending on what the user wants, it can display a variety of
data. Performance bottlenecks is one such annotation. Others include
garbage collection, runtime dispatch, module access (for security),
purity, and code coverage.


\section{Translation}

A long term goal of Cottontail is to allow all users to program using
their native language. This is sometimes called ``natural language
programming'', and while its usage in large projects is controversial,
it should give beginners a large benefit (especially children, who may
not have extensive English knowlege).

The symbol set is intentionally chosen to support a wide variety of
international keyboards, and alternative symbols are supported when
applicable. Likewise, there are no syntax rules requiring capital
letters or the Latin alphabet. With translated function, property, and
module names, it should be possible to write code that only uses
native words. Since all translations are in scope, it will be possible
to mix and match languages within the same file, and to use modules
written in another native tongue.


\section{Portability}

Cottontail is a language intended to be run on many different kinds of
computers. For now this means Linux, Windows, BSD, Mac OS X, Android,
and iOS; running on x86, amd64, MIPS, and ARM processors. It should be
the case that code written in Cottontail will run on any of these
platforms, but complexities such as user interfaces may require
platform-specific code.


\section{Error handling}

When faced with errors, Cottontail always tries to fail fast. This is
the strategy followed by Erlang, and it allows more errors to be
discovered at their source. (Compare to a null pointer in Java that
doesn't get discovered until millions of statements after the ``if
error return null''.) In these situations, Cottontail libraries should
always throw exceptions.

Error messages themselves should be clear and articulate, in the
spirit of Clang. In general, encountering an error will trigger the
REPL to open at the point of error, with highlighted text, a full
backtrace, and live diagnostic information. This applies for runtime
errors as well as compilation errors. Generic typing errors in
Cottontail will be quite subtle at times, so a full REPL will help
with debugging.


\section{Documentation}

Documention covers a full range of mediums. There are formal documents
such as this book, which includes tutorials and specifications. A
supplementary online wiki will have further tutorials and code
snippets. Blog posts which cover topics in depth will be aggregated,
and maybe catalogued. API documentation should be as slick as Sphinx
and should include ``see source'' links just like Haddock. It should
also include arities and example usages, because Cottontail types
can't be named in code. Lastly documentation will be available at
the REPL for any function or module with API docs.

Building, coordinating, and maintaining all of this will doubtless be
a giant undertaking. It needs to be tackled smartly so that
consistency and sanity can be maintained. Moreover, all text must be
written clearly and humbly, to ensure enjoyable and friendly readings.
