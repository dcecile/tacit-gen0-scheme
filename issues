- releasing
- Unicode lexing
  - and good enough host language
- iter and zip
- custom iters using yield (eg. pure coroutines over continuations)
- coroutine basis
- finite and infinite ranges
- control-flow keywords and shadowing (eg. run, else...)
- parsing error messages
- C++ const-ref/ref and closures
- bland syntax (try highlighting)
- backwards lists (rev fn?)
- custom control-flow syntax
- monads
- accurate translations (Japanese/French)
  - function names
  - keyboard/symbol mapping
  - automatic transliteration
- internationalized literal number parsing
- identifier parsing affected by internationalized syntax
- string localization syntax
  - format strings that aren't really annoying for Japanese translators and are okay for quick hacks
  - comments
  - translation workflow (review, notes, updated source, ignored autoinclude)
  - i18n string literal management: archived decisions on whether to translate strings or not
- parentheses closing before colon
- multisetref shortcut
- constrained matrices
- namings of map/filter/reduce variants (zip, maybe, cat, plus, and)
  - eg. ^+ ([+] 0 reduce0), ^cat ([cat] empty reduce0), 
- recursive types (x def: "hi" [x]) (denotationally impossible types)
- superb type inference
- type ambiguity resolution helpers
- malloc-level Cottontail for bootstrapping data-structures
- internal versus external reqs (+ resolving variants)
  - try to restrict internal requirements to pure functions, no shadow-variable stuff (eg x &= req-nothing)
- loops for imperative beginners/oldtimers
- using = for impure reference updates doesn't rebind so maybe use a different symbol?
  - eg. x.$y $= 3
- name for "use but don't dump into my namespace"
  - useful, or not? (ie. restricted @ns symbols)
- locale effects:
  - number formats
  - date formats
  - developer error messages
  - user error messages
  - log messages
  - UI strings
  - string sorting, casing
  - keyboard hotkeys
  - linebreaking
- Unicode lexing considerations:
  - identifier/security:
      - combining character order (hopefully normalization takes care of it) (non-interacting vs. interacting composing characters)
      - overlaid diacritics (likely imposible, or do "search without accents" like NFD)
  - don't break ligated glyphs like fi and SS
- string literal escapes
  - Unicode specifically avoided escape sequences due to context dependencies
  - just use other delimiters
  - or name the codepoint
  - or write the codepoint number (U+0020 is a valid identifier, or it could be primitive)
  - what about format strings?
  - yet still localizable (eg. localize an evaluation)
- localizable expressions
- installer support (see Bauerbill)
