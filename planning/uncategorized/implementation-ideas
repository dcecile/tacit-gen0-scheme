Compile speed:
- off-thread compilation
  - after second time through interpreting a function, queue it on the compiler
  - compiler has a very short queue or some kind of hotness priority feature
  - next time the function needs execution, context switch to the compiled version
- function lookup (for all Unicode character names)
  - in-memory hash-sets
  - SQLite database on hits (or one of those cool hierachical plain text databases)
  - cached using hash of compressed source file
- installer support
  - see Bauerbill, PackageKit, WiX, Pause6

Self-hosting:
- malloc-level Cottontail for bootstrapping data-structures

Localizable expressions:
- converted to YAML
  - from: ["Import " s0 " as " s1] tr
  - to: ["Import ", s0@adlib, " as ", s1@adlib] # really, this is backwards
  - not much use, due to common whitespace
- simplicity probably wins: "Import {0} as {1}" tr
  - any crazy number formatting etc. will be done using functions; it's not useful at all for i18n
  - escapes, well just do {{ and }}

Translator features:
- run the app and it logs string usage (for determining translation priority) (not a lot of help for games)

On-the-fly locale changes:
- each translated string keeps a copy of a lambda that can be used to retranslate itself, using positional arguments too
- master-table of translated strings and UI update lambdas

Project-file solution:
- problem: there are some default behaviours needed for source files, eg. default imports, default style, default source number locale
  - but running the interpreter from a leaf node (eg. running tests, using the REPL) would be in another directory, so any project definition file wouldn't be found
  - some strangeness involved with bundle distro and inclusion and multiple projects with common module hierarchies (or overriden behaviour for internal subprojects)
- on bundle creation, the main project file is autogenerated, putting in the current locale that's been used for numeric parsing and translation source language
  - a file is put in all subdirectories for the project, naming the location of the project root
  - eg. under text/yaml/parsing/fast there'd be a link saying "text.yaml"
  - it's easy to find the way down the tree to the project root
- drawback: you can't put multiple projects in the same directory
  - the project file and the project link files have well-known, fixed names

Serialization:
- use schemas when performance is desired over flexibility
- recompile code after serialized data structures are deserialized
  - specialize for run-time data
- metadata last resort: magic comments

Coverage:
- fills in words at a time with green background
- strike-through non-executed (or something good enough for colour blindness/blindness)

Recoverable compile errors:
- if possible, start with files that have been changed most recently
- use "parser recovery" (try putting something in, see if it works, give it as a suggestion)

Error display:
- for plain exceptions, and for parser errors
- highlight bad text in interactive log (OCaml)
- split text onto to lines, at the point of error (TeX)

Concurrency:
- promise events (E), queueing discipline (Teatime): http://lambda-the-ultimate.org/node/4053

Package resolution:
- see problem with Scala (unintended shadowing only with Java not .NET): http://www.artima.com/scalazine/articles/chained_package_clauses_in_scala.html
