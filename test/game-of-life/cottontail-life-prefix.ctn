enum alive
enum enum

def get-cell grid x y:
  x &= grid.width mod
  y &= grid.width mod
  grid.cells y >> x >>

def near i:
  i repeat  -1 1 range  [+]  zipmap

def neighbours grid x y:
  pairs = y near _ map: y' ->
    x near _ map: x' ->
      [y' x']
  pairs &= uncurry filter: y' x' ->
    x' x neq  y' y neq  or
  pairs _ uncurry map: y' x' ->
    grid y' x' get-cell

def living-neighbours:
  neighbours  [alive eq] filter  count

def evolve-cell s n:
  s match:
    dead, n match:
      3, alive
      else, dead
    alive, when:
      n 3 >, dead
      n 2 <, dead
      else, alive

def evolve-grid grid:
  grid.cells =
    0 grid.height range grid.cells zipmap: r y ->
      0 grid.width range r: x s ->
        s grid x y living-neighbours evolve-cell
  grid

def generations: [evolve-grid] iterate

def make-grid pattern width height:
    cells = pattern _ map: p ->
      [alive dead] cycle p zip
        [replicate] uncurry
        mapcat
    cells count height eq assert
    cells [count width eq] every assert
    mk:
      cells = cells
      width = width
      height = height

def show-cell:
  match:
    alive, '[X]'
    dead,  ' . '

def show-row:
  [show-cell] mapcat

def show-grid:
  .cells [show-row] map

def put-grid:
  show-grid [say] each

def put-generations start n:
  start generations n take
    [put-grid newline] each

def blinker: [
    [5]
    [5]
    [1 3 1]
    [5]
    [5]
    ] 5 5 make-grid

def figure-eight: [
    [10]
    [10]
    [2 3 5]
    [2 3 5]
    [2 3 5]
    [5 3 2]
    [5 3 2]
    [5 3 2]
    [10]
    [10]
    ] 10 10 make-grid

def glider: [
    [7]
    [7]
    [7]
    [3 3 1]
    [3 1 3]
    [4 1 2]
    [7]
    ] 7 7 make-grid

def lineGun: [
    [40]
    [1 5 1 6 6 3 3 5 1 8 1]
    [40]
    ] 40 2 make-grid
