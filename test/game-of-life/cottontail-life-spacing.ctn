alive enum
dead enum

get-cell  grid x y def:
  x &= grid.width mod
  y &= grid.width mod
  grid.cells y >> x >>

near  i def:
  i repeat  -1 1 range  [+]  zipmap

neighbours  grid x y def:
  pairs = y near _ map: y' ->
    x near _ map: x' ->
      [y' x']
  pairs &= uncurry filter: y' x' ->
    x' x neq  y' y neq  or
  pairs _ uncurry map: y' x' ->
    grid y' x' get-cell

living-neighbours def:
  neighbours  [alive eq] filter  count

evolve-cell  s n def:
  s match:
    dead, n match:
      3, alive
      else, dead
    alive, when:
      n 3 >, dead
      n 2 <, dead
      else, alive

evolve-grid  grid def:
  grid.cells =
    0 grid.height range grid.cells zipmap: r y ->
      0 grid.width range r: x s ->
        s grid x y living-neighbours evolve-cell
  grid

generations def: [evolve-grid] iterate

make-grid  pattern width height def:
    cells = pattern _ map: p ->
      [alive dead] cycle p zip
        [replicate] uncurry
        mapcat
    cells count height eq assert
    cells [count width eq] every assert
    mk:
      cells = cells
      width = width
      height = height

show-cell def:
  match:
    alive, '[X]'
    dead,  ' . '

show-row def:
  [show-cell] mapcat

show-grid def:
  .cells [show-row] map

put-grid def:
  show-grid [say] each

put-generations  start n def:
  start generations n take
    [put-grid newline] each

blinker def: [
    [5]
    [5]
    [1 3 1]
    [5]
    [5]
    ] 5 5 make-grid

figure-eight def: [
    [10]
    [10]
    [2 3 5]
    [2 3 5]
    [2 3 5]
    [5 3 2]
    [5 3 2]
    [5 3 2]
    [10]
    [10]
    ] 10 10 make-grid

glider def: [
    [7]
    [7]
    [7]
    [3 3 1]
    [3 1 3]
    [4 1 2]
    [7]
    ] 7 7 make-grid

lineGun def: [
    [40]
    [1 5 1 6 6 3 3 5 1 8 1]
    [40]
    ] 40 2 make-grid
